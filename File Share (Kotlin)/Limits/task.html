<div class="step-text">
<p></p><h5 id="description">Description</h5><p>The file-sharing service is going well, but you have received reports that malicious users abuse it:</p><ul><li><p>They upload tons of files, consuming the entire available space and making the service unavailable to other users.</p></li><li><p>They upload huge files consuming the server's bandwidth and generating traffic.</p></li><li><p>They upload suspicious files you prefer not to keep on the server, including executable files and scripts.</p></li></ul><p>After a while, you decided to limit the total storage space available to clients, as well as the maximum size of uploaded files. In addition, you decided to allow only plain text files and <em>JPEG</em> and <em>PNG</em> images for uploading. The server should reject any other file types. These measures will help protect the service from those kinds of attacks.</p><p>Let's think about how you can enforce such limitations.</p><p>Limiting the storage space and incoming file size is pretty easy. However, filtering out unwanted files is not.</p><p>Making a white list of file extensions won't help because a malicious user can disguise a binary file as an image or text file by changing its extension to <em>.jpeg</em> or <em>.txt</em>. Checking the declared content type of the request doesn't guarantee anything either because a malicious user can change the content type as well.</p><p>However, it is known that:</p><ul><li><p>each <em>PNG</em> file starts with the following bytes (shown in hexadecimal format): <code class="language-kotlin">89 50 4E 47 0D 0A 1A 0A</code>.</p></li><li><p>each <em>JPEG</em> file starts with <code class="language-kotlin">FF D8</code> and ends with <code class="language-kotlin">FF D9</code> bytes.</p></li><li><p>each plain text file in UTF-8 encoding can contain only valid UTF-8 byte sequences.</p></li></ul><p>You can utilize this knowledge to verify each uploaded file. These checks are not foolproof but will be enough for this project. In a real-life project, more sophisticated solutions will be required.</p><p>The other functionality of the service should remain the same.</p><h5 id="objectives">Objectives</h5><ul><li><p>Limit the total storage space to 200KB (1K = 1000). If an uploaded file is larger than the remaining available space, the <code class="language-kotlin">POST /api/v1/upload</code> endpoint should respond with the status code <code class="language-kotlin">413 PAYLOAD TOO LARGE</code>.</p></li><li><p>Limit the maximum size of the uploaded file to 50KB (1K = 1000). If an uploaded file is larger than the allowed maximum size, the <code class="language-kotlin">POST /api/v1/upload</code> endpoint should respond with the status code <code class="language-kotlin">413 PAYLOAD TOO LARGE</code>.</p></li><li><p>Verify each uploaded file. Reject any request if the media type of the uploaded file is not <code class="language-kotlin">text/plain</code>, <code class="language-kotlin">image/jpeg</code> or <code class="language-kotlin">image/png</code>. You can obtain this information from the <code class="language-kotlin">MultipartFile</code> interface.</p></li><li><p>If the media type of the uploaded file is in the whitelist, verify that the content of the file does match the pattern:<br/>- for the <code class="language-kotlin">image/png</code>, check if its first bytes are <code class="language-kotlin">89 50 4E 47 0D 0A 1A 0A.</code><br/>- for the <code class="language-kotlin">image/jpeg</code>, check if its first bytes are <code class="language-kotlin">FF D8</code> and its last bytes are <code class="language-kotlin">FF D9</code>.<br/>- for the <code class="language-kotlin">text/plain</code>, attempt to decode the file contents with a <code class="language-kotlin">CharsetDecoder</code> and see if no <code class="language-kotlin">CharacterCodingException</code> is thrown, which means that the content has only valid UTF-8 byte sequences:</p><pre><code class="language-kotlin">import java.nio.ByteBuffer
import java.nio.charset.CharsetDecoder
import java.nio.charset.StandardCharsets

class SomeClass {
    fun someFun(MultipartFile file) {
        try {
            val contents: ByteArray = file.bytes
            val utf8Decoder: CharsetDecoder = StandardCharsets.UTF_8.newDecoder()
            utf8Decoder.reset()
            utf8Decoder.decode(ByteBuffer.wrap(contents))
            // no exception - the byte array contains only valid UTF-8 byte sequences
        } catch (e: CharacterCodingException) {
            // handle exception - the byte array contains invalid UTF-8 byte sequences
        }
    }
}</code></pre><p> If the file fails verification, the <code class="language-kotlin">POST /api/v1/upload</code> endpoint should respond with the status code <code class="language-kotlin">415 UNSUPPORTED MEDIA TYPE</code>. </p></li><li><p>In the case that an uploaded file should be rejected for multiple reasons, first check if it should be rejected because of its size (file too large, free storage space is not enough), then check if it should be dismissed because of its contents (media type is not in the whitelist, actual content does not match the declared media type).</p></li></ul><h5 id="examples">Examples</h5><p><strong>Example 1</strong>. <em>POST request to </em><code class="language-kotlin">/api/v1/upload</code> with a multipart file named "file.txt"</p><p><em>Response code</em>: <code class="language-kotlin">201 CREATED</code></p><p>Response header: <code class="language-kotlin">Location: http://localhost:8888/api/v1/download/12</code></p><p><strong>Example 2</strong>. <em>POST request to </em><code class="language-kotlin">/api/v1/upload</code> with a multipart file named "virus.exe"</p><p><em>Response code</em>: <code class="language-kotlin">415 UNSUPPORTED MEDIA TYPE</code></p><p><strong>Example 3</strong>. <em>POST request to </em><code class="language-kotlin">/api/v1/upload</code> with a multipart file containing the "virus.exe" file disguised as "text.txt"</p><p><em>Response code</em>: <code class="language-kotlin">415 UNSUPPORTED MEDIA TYPE</code></p><p><strong>Example 4</strong>. <em>POST request to </em><code class="language-kotlin">/api/v1/upload</code> with a multipart file with a size of over 50KB</p><p><em>Response code</em>: <code class="language-kotlin">413 PAYLOAD TOO LARGE</code></p><p><strong>Example 5</strong>. <em>POST request to </em><code class="language-kotlin">/api/v1/upload</code> with a multipart file with a size less than 50KB, but the free space on the server is not enough</p><p><em>Response code</em>: <code class="language-kotlin">413 PAYLOAD TOO LARGE</code></p>
</div>